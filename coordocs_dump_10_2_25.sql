-- phpMyAdmin SQL Dump
-- version 4.9.0.1
-- https://www.phpmyadmin.net/
--
-- Host: sql101.infinityfree.com
-- Generation Time: Oct 02, 2025 at 05:37 PM
-- Server version: 11.4.7-MariaDB
-- PHP Version: 7.2.22

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
SET AUTOCOMMIT = 0;
START TRANSACTION;
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;

--
-- Database: `if0_35615011_orbs`
--

-- --------------------------------------------------------

--
-- Table structure for table `projects`
--

CREATE TABLE `projects` (
  `id` bigint(20) NOT NULL,
  `name` varchar(1024) NOT NULL,
  `userID` bigint(20) NOT NULL,
  `data` mediumtext NOT NULL,
  `slug` varchar(32) NOT NULL,
  `private` tinyint(1) NOT NULL,
  `created` timestamp NOT NULL DEFAULT current_timestamp(),
  `updated` timestamp NOT NULL DEFAULT current_timestamp(),
  `views` bigint(20) NOT NULL DEFAULT 0
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

--
-- Dumping data for table `projects`
--

INSERT INTO `projects` (`id`, `name`, `userID`, `data`, `slug`, `private`, `created`, `updated`, `views`) VALUES
(2138693765726537, 'Coordinates.js (section 3)', 1, '## Tips and tricks\n\n### textures\n\nVideos and images are interchangeable as texture sources. A video may be referenced numerous times as a shape texture and / or as a reflection map, without concern for performance degradation as a result of the multiple references, however video frame calls themselves at render time do impact performance.<br><br>\nCoordinates involves an internal cache for all network resource calls with the URL as a key. There may be occasions to bypass the cache (e.g. displaying the same video at a different speed on two objects), in which case you may inoke the ``involveCache: false`` property which forces a new instance of that resource, available on all configurations where network resources apply. If the involveCache property is used and set to false, the order in which calls occur is relevant to the resulting settings for each instance. Some experimentation may be called for to achieve your desired results.<br><br>\n\nIf your texture appears faded or you can\'t get the lighting / colors crisp with the desired contrast, this may be due to the shape\'s colorMix, which has a nonzero default value. Try setting ``colorMix: 0`` for your geometry, which removes the shape\'s color from the mix.\n\n\n#### canvasTexture\nGeometry loaded with the LoadGeometry method accepts a texture \'map\', but a canvas may also be passed, in addition or by itself. The canvas reference is read at the time the shape is drawn, allowing for dynamic textures. Canvases passed may be 2d, webgl, or even a reference to Coordinates renderer screen via the ``renderer.c`` property.\n\nExample:\n```js\nvar rendererOptions = {\n  ambientLight: .5,\n  fov: 1500,\n}\nvar renderer = await Coordinates.Renderer(rendererOptions)\n\nrenderer.z = 10\n\nCoordinates.AnimationLoop(renderer, \'Draw\')\n\nvar shaderOptions = [\n  { uniform: {\n    type: \'phong\',\n    value: .75,\n  } }\n]\nvar shader = await Coordinates.BasicShader(renderer, shaderOptions)\n\n\nvar shapes = []\n\nvar myCanvas = document.createElement(\'canvas\')\nmyCanvas.width = 512\nmyCanvas.height = 512\nvar ctx = myCanvas.getContext(\'2d\')\nconst updateMyCanvas = () => {\n  ctx.fillStyle = \'#000\'\n  ctx.fillRect(0, 0, myCanvas.width, myCanvas.height)\n  for(var i = 0; i<3; i++){\n    var p = Math.PI * 2 / 3 * i + renderer.t * 8\n    var X = myCanvas.width/2  + Math.sin(p) * 100\n    var Y = myCanvas.height/2  + Math.cos(p) * 100\n    ctx.beginPath()\n    ctx.arc(X, Y, 50,0,7)\n    ctx.fillStyle = \'#f00\'\n    ctx.fill()\n  }\n}\n\nvar geoOptions = {\n  shapeType: \'cube\',\n  size: 5,\n  subs: 3,\n  canvasTexture: myCanvas,\n  canvasTextureMix: 1,\n  color: 0x0000ff\n}\nawait Coordinates.LoadGeometry(renderer, geoOptions).then(async (geometry) => {\n  shapes.push(geometry)\n  await shader.ConnectGeometry(geometry)\n})  \n\n\nwindow.Draw = () => {\n  updateMyCanvas()\n  shapes.forEach(shape => {\n    shape.yaw += .01\n    shape.pitch += .005\n    renderer.Draw(shape)\n  })\n}\n```\n\nThis creates such output<br>\n<center>\n\n![example2](https://srmcgann.github.io/Coordinates/img/README_g2.gif) </center>\n', '9NiTZsLqN', 0, '2025-10-02 19:50:12', '2025-10-02 19:50:12', 6),
(3368747454397786, 'ShapeFromArray', 1, '# shape arrays\n<iframe style=\"width: 480px; height: 270px; border: none; border-radius: 10px;\" src=\"https://srmcgann.github.io/Coordinates/examples/ShapeArraysSimple.html\"></iframe>\n\n`Coordinates.ShapeFromArray(shape, pointArray, options)`<br>\nShapeArrays are useful for grouping like-type geometries, as well as boosting performance in heavy scenes. A large number of shapes may be drawn with a single call to `renderer.Draw()`. Group and individual component transformations are possible at creation time, draw time\n\n### geometry.shapeData\n* components remain addressable by writing to `shapeData`, a special structure attached to the geometry at creation time<br>\ngeometry returned by `ShapeFromArray` is like from `LoadGeometry`, with special properties:\n\n- `stride` the number of elements per component in the geometry\'s vertices/normalVecs arrays, if needed\n- `shapeData` for controlling the shape\'s internal components individually\n\nA simple example\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>Coordinates boilerplate example</title>\n    <style>\n      body, html{\n        background: #000;\n        margin: 0;\n        min-height: 100vh;\n        overflow: hidden;\n      }\n    </style>\n  </head>\n  <body>\n    <script type=\"module\">\n    \n      import * as Coordinates from\n     // \"https://boss.veriler.com/coordinates.js\"\n      \"https://srmcgann.github.io/Coordinates/coordinates.min.js\"\n    \n      var renderer = await Coordinates.Renderer()\n      \n      \n      Coordinates.AnimationLoop(renderer, \'Draw\')\n\n      var shaderOptions = [ { uniform: { type: \'phong\', value: .75 } } ]\n      var shader = await Coordinates.BasicShader(renderer, shaderOptions)\n\n      // declare a name\n      var myShapeArray \n      // populate an array of \'points\', which will be replaced by instances of the source shape\n      var cl = 10, rw = 10, br = 10\n      var sourceArray = []\n      Array(cl*rw*br).fill().map((v, i) => {\n        var x = (i%cl)-cl/2+.5\n        var y = ((i/cl|0)%rw)-rw/2+.5\n        var z = (i/cl/br|0)-br/2+.5\n        if(Math.hypot(x,y,z) < cl/1.75) sourceArray.push([x, y, z])\n      })\n      \n      var geoOptions = {\n        shapeType: \'cube\',\n        size: .2,\n        colorMix: 1,\n        averageNormals: true,\n        subs: 1,\n        scaleY: 2,\n        sphereize: -.25\n      }\n      await Coordinates.LoadGeometry(renderer, geoOptions).then(async geometry => {\n        Coordinates.ShapeFromArray(geometry, sourceArray).then(async geometry => {\n          myShapeArray = geometry\n          await shader.ConnectGeometry(geometry)\n        })\n      })  \n      \n      \n      window.Draw = () => {\n        renderer.z = Math.min(6, Math.max(3, (.3+Math.cos(renderer.t))*10))\n        \n        // rotate every 10th component indpendently\n        for(var i = 0; i < myShapeArray.shapeData.length; i+=10) {\n          myShapeArray.shapeData[i].yaw += .1\n          myShapeArray.shapeData[i].roll += .02\n          myShapeArray.shapeData[i].pitch += .01\n        }\n        myShapeArray.yaw  += .002\n        myShapeArray.pitch += .0005\n        renderer.Draw(myShapeArray)\n      }\n      \n    </script>\n  </body>\n</html>\n```\nthis produces such a result\n<iframe style=\"width: 480px; height: 270px; border: none; border-radius: 10px;\" src=\"https://srmcgann.github.io/Coordinates/examples/ShapeArraysSimple.html\"></iframe>\n\nobserve that some of the shape\'s components are spinning, while the entire shape is drawn with one call to `renderer.Draw` per frame.<br>\n\nthe structure of the `shapeData` attribute is shown in the example below\n```\n// console.log(shape.shapeData)\n[\n    {\n        \"ox\": -1.5,\n        \"oy\": -2.5,\n        \"oz\": -4.5,\n        \"wx\": -1.5,\n        \"wy\": -2.5,\n        \"wz\": -4.5,\n        \"x\": 0,\n        \"y\": 0,\n        \"z\": 0,\n        \"roll\": 5.46,\n        \"pitch\": 2.73,\n        \"yaw\": 27.3,\n        \"mx\": 0,\n        \"my\": 0,\n        \"mz\": 0,\n        \"mroll\": 5.46,\n        \"mpitch\": 2.73,\n        \"myaw\": 27.3\n    },\n  // ...\n]\n```\n\nthese properties are all read/writable, but the ones beginning with \'m\' are for internal purposes.\nOrdinarily only `x,y,z, roll, pitch, yaw` will be used at this time. If the components\' current \'world\' position is needed, this is stored in `wx, wy, wz`, updated at draw-time.\n', 'fqAGEVGSC', 0, '2025-08-13 01:48:43', '2025-08-13 01:48:43', 66),
(3594999117147136, 'raw shapes', 1, '# raw shapes\n\nthe geometry constructors are exposed for convenience, including\n\n* Tetrahedron\n* Cube\n* Octahedron\n* Dodecahedron\n* Icosahedron\n* Torus\n* TorusKnot\n* Rectangle\n* Cylinder\n\nthis complete example uses the `Icosahedron` method to manually create `custom shape` geometry data\n```js\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>Coordinates boilerplate example</title>\n    <style>\n      body, html{\n        background: #333;\n        margin: 0;\n        min-height: 100vh;\n        overflow: hidden;\n      }\n    </style>\n  </head>\n  <body>\n    <script type=\"module\">\n    \n      import * as Coordinates from\n      \"https://srmcgann.github.io/Coordinates/coordinates.min.js\"\n    \n      var rendererOptions = {\n        ambientLight: .5,\n        fov: 1500\n      }\n      var renderer = await Coordinates.Renderer(rendererOptions)\n      \n      Coordinates.AnimationLoop(renderer, \'Draw\')\n\n      var shaderOptions = [\n        { uniform: {\n          type: \'phong\',\n          value: .75\n        } }\n      ]\n      var shader = await Coordinates.BasicShader(renderer, shaderOptions)\n\n      renderer.z = 10\n\n      var shapes = []\n      \n      \n      \n      // raw shape section\n      \n      var shape = {\n        vertices: new Float32Array(),\n        normals:  new Float32Array(),\n        uvs:      new Float32Array()\n      }\n\n      await Coordinates.Icosahedron(8).then(shp => {\n        shp.geometry.map(val => {\n          shape.vertices = [...shape.vertices, ...val.position]\n          shape.normals  = [...shape.normals,  ...val.normal]\n          shape.uvs      = [...shape.uvs,      ...val.texCoord]\n        })\n      })\n\n      shape.normalVecs = new Float32Array()\n      const n = shape.normals\n      for(var i=0; i<n.length; i+=6){\n        let X = n[i+3] - n[i+0]\n        let Y = n[i+4] - n[i+1]\n        let Z = n[i+5] - n[i+2]\n        shape.normalVecs = [...shape.normalVecs, X,Y,Z]\n      }\n      \n      ///////////////////////\n      \n\n      var geoOptions = {\n        shapeType: \'custom shape\',\n        geometryData: shape,\n        color: 0xffffff\n      }\n      await Coordinates.LoadGeometry(renderer, geoOptions).then(async (geometry) => {\n        shapes.push(geometry)\n        await shader.ConnectGeometry(geometry)\n      })\n      \n      window.Draw = () => {\n        shapes.forEach(shape => {\n          shape.yaw += .01\n          shape.pitch += .005\n          renderer.Draw(shape)\n        })\n      }\n      \n    </script>\n  </body>\n</html>\n```\nproducing such effect\n<iframe style=\"width: 480px; height: 270px; border: none; border-radius: 10px;\" src=\"https://srmcgann.github.io/Coordinates/examples/Icosahedron.html\"></iframe>\n\nnote: the exposed methods shown above may be used, or procedurally-generated data from formulas', 'gsPYtHhNC', 0, '2025-08-14 00:47:25', '2025-08-14 00:47:25', 8),
(3818763443435888, 'Coordinates.js (section 4)', 1, '## Plugins\n\n### Post Processing\nCamera/renderer objects returned by the ``Renderer()`` method, may include a plugin stack, optionally. The library of available plugins is growing but here is one example:<br>\n\n```js\nvar rendererOptions = {\n  ambientLight: .5,\n  fov: 1500,\n  margin: 0,\n  plugins: [\n    {\n      type: \'post processing\',\n      value: \'equirectangular\',\n      enabled: true,\n    }\n  ],\n}\nvar renderer = await Coordinates.Renderer(rendererOptions)\n\nCoordinates.AnimationLoop(renderer, \'Draw\')\n\nvar shaderOptions = [\n  { uniform: {\n    type: \'phong\',\n    value: .5\n  } }\n]\nvar shader = await Coordinates.BasicShader(renderer, shaderOptions)\n\nvar shapes = []\n\nvar cl = 2, rw = 2, br = 2, sp = 8\nfor(var i = 0; i<cl*rw*br; i++) {\n  var x = ((i%cl) -cl/2) * sp\n  var y = (((i/cl|0)%rw) - rw/2 + .5) * sp\n  var z = ((i/cl/rw|0)-br/2 + .5) * sp\n  var geoOptions = {\n    shapeType: \'cube\',\n    x, y, z,\n    size: 2,\n    subs: 2,\n    colorMix: .6\n  }\n  await Coordinates.LoadGeometry(renderer, geoOptions).then(async (geometry) => {\n    shapes.push(geometry)\n    await shader.ConnectGeometry(geometry)\n  })  \n}\n\nrenderer.z = 0\n\nwindow.Draw = () => {\n  var t = renderer.t\n  renderer.yaw   = t\n  renderer.pitch = t\n  shapes.forEach(shape => {\n    shape.yaw   += .01\n    shape.pitch += .05\n    renderer.Draw(shape)\n  })\n}\n```\nThis creates such output<br>\n<center>\n\n![example4](https://srmcgann.github.io/Coordinates/img/README_g4.gif) </center>\n\n', 'huntg2zQY', 0, '2025-10-02 19:54:01', '2025-10-02 19:54:01', 6),
(4122261557995567, 'ShapeToLines', 1, '# ShapeToLines method (vs wireframe: true)\n<iframe style=\"width: 480px; height: 270px; border: none; border-radius: 10px;\" src=\"https://srmcgann.github.io/Coordinates/examples/ShapeToLines.html\"></iframe>\n\n`Coordinates.ShapeToLines(shape, options)`\n\nGeometries retruned by `LoadGeometry` may be converted to lines/wireframe shapes with the `ShapeToLines` method, as shown:\n\n```js\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>Coordinates boilerplate example</title>\n    <style>\n      body, html{\n        background: #000;\n        margin: 0;\n        min-height: 100vh;\n        overflow: hidden;\n      }\n    </style>\n  </head>\n  <body>\n    <script type=\"module\">\n    \n      import * as Coordinates from\n      \"https://srmcgann.github.io/Coordinates/coordinates.min.js\"\n    \n      var renderer = await Coordinates.Renderer()\n      Coordinates.AnimationLoop(renderer, \'Draw\')\n\n      var myShape\n      await Coordinates.LoadGeometry(renderer, {\n        shapeType: \'cube\',\n        size: 5,\n      }).then(async geometry => {\n        Coordinates.ShapeToLines(geometry, {\n          size: 2,\n          color: 0x4400ff,\n          alpha: .5,          // opacity, 0.0 - 1.0\n          penumbra: .1,       // \"glow\" amount, 0.0 - 1.0, relative to alpha\n          closePaths: false,  // optional - close polygons. default = true\n        }).then(res => {\n          myShape = res.shape\n        })\n      })  \n      \n      window.Draw = () => {\n        renderer.z = 6\n        renderer.yaw = renderer.t\n        renderer.pitch = .1\n        renderer.Draw(myShape)\n      }\n      \n    </script>\n  </body>\n</html>\n```\n\nNote: this method differs from the `wireframe: true` geometry option, in that these lines are variable size, opacity, and are in fact polygons created by coordinates.js, whereas the wireframe property merely uses the webgl in-built drawElements `gl.LINES` type', 'iSyJ2lMJN', 0, '2025-08-13 20:12:16', '2025-08-13 20:12:16', 36),
(5593987592387351, 'Coordinates.js (section 2)', 1, '## methods, options, and their defaults\n#### Renderer()\n``Coordinates.Renderer( rendererOptions )``\n##### returns a camera object, creates a canvas, async\n```js\nvar rendererOptions = {\n  alpha: false,\n  width: 1920,  // the interior viewport dimensions (pixels)\n  height: 1080,\n  clearColor: 0x333333,  // grey\n  fov: 2e3,  // \"field of vision\", the camera\'s focal length\n             // useful range:\n             //   500 (perspective) to 100,000 (orthographic)\n  ambientLight: .5,\n  x:    0, y:     0, z:   0,\n  roll: 0, pitch: 0, yaw: 0,\n  margin: 10,  // the viewport will expand to fill as much of the\n               // visible page as possible, resizing automatically,\n               // with a margin of this amount\n  attachToBody: true, // this can be set to false, for\n                      // background/buffer operations if needed\n  context: {\n    mode: \'webgl\',    // 2d is semi-implemented,\n                      // not working at this time\n    options: {\n      alpha:         true,\n      antialias:     true,\n      desynchronize: true,\n    }\n  },\n  plugins: [                    // optional plugins.\n    {\n      enabled: true\n      type: \'post processing\',      // plugin type.\n      value: \'equirectangular\',     // the subtype.\n      params: [ \'omitSplitCheck\' ], // optional performance\n                                    // optimization. see notes\n                                    // and example below.\n    }\n  ],\n}\n```\n<br>\n\nAdditionally, a Renderer object contains a number of useful properties, auto-updated:\n```js\nrenderer.pageX        // window mouse x coordinate\nrenderer.pageY        // window mouse y coordinate\nrenderer.mouseX       // internal canvas mouse x coordinate\nrenderer.mouseY       // internal canvas mouse y coordinate\nrenderer.mouseButton  // the browser window mouse button status\n```\n...and others. feel free to view a renderer object in your browser console:\n``console.log(renderer)``\n<br>\n<br>\n\n\n## DestroyRenderer()\n\n``Coordinates.DestroyRenderer(renderer)``<br>\nWhen a camera/renderer is instantiated it may begin an animation loop, as well as place a canvas on the screen. Pass a renderer object to this method to elminate the canvas and cancel the loop, e.g. for performance reasons.<br>\n<br>\n\n## LoadFPSControls()\n\n``Coordinates.LoadFPSControls(renderer, options)``<br>\nBy default, a renderer/camera object \'orbits\' the center point of the coordinate system. This may be useful in some cases but a mobile camera is also exposed via the ``LoadFPSControls`` method. \'FPS\' stands for \'First Person Shooter\', which loads a game style camera with appropriate mechanics, enabling the following:\n\n  * basic keyboard controls:<br>\n     W / A / S / D      -> move around<br>\n     arrow keys / mouse -> look around<br>\n     shift              -> run / speed boost<br>\n  * optional crosshair, centered<br>\n  * arbitrary camera movment<br>\n\nNote: the optional properties below are also added to the renderer object, which is handy for toggling or resetting values on the fly.\n\nLoading example [with default values]:\n\n```js\nvar FPSOptions = {\n  showCrosshair: true,  // whether or not to display a crosshair.\n  crosshairSize: 1,     // crosshair graphic size multiplier\n  crosshairSel:  0,     // Three premade crosshair graphics are available,\n                        // or a custom graphic may be used.\n  crosshairMap:  \'\',    // Optional URL to a custom crosshair graphic.\n                        // If provided, the custom crosshair should be png\n                        // if it involves transparency.\n  mSpeed:        1.0,   // constant movement speed multiplier.\n  rSpeed:        1.0,   // constant rotational speed multiplier.\n  focusRequiredForMouse: true,  // if set to false, mouse-over is processed without clicking\n  useKeys:       true,  // enabled by default, you may use the FPS camera only,\n                        // without keys/mouse, by setting useKeys: false. This\n                        // might be useful for environments where the default\n                        // center-pointing camera isn\'t appropriate.\n  flyMode:       false, // un-restrict camera movement.\n                        // by default the camera is pinned to Y=0.\n                        // with flyMode enabled, mousebuttons will control vertical\n                        // movement, in addition to the usual keys\n  grav:          .01,   // a gravity value, if needed\n}\nawait Coordinates.LoadFPSControls(renderer, FPSOptions)\n\n// optionally, the controls may be unloaded...\nCoordinates.UnloadFPSControls(renderer)\n```\n\n<center>\n\n![crosshairSel](https://srmcgann.github.io/Coordinates/img/crosshairSel.jpg) </center>\n\nIf a custom crosshairMap is used, it becomes a 4th element (3) in the crosshairSel array [0, 1, 2, 3]. If specified, crosshairSel is set to this automatically, but can be changed, or changed back.\n\nNotes: The FPS camera config options are added to the renderer object when the FPS camera is loaded. For example, ``crosshairSel``, ``showCrosshair`` may be changed on the fly by setting ``renderer.crosshairSel = ...`` etc.\n\nIt\'s important also to be aware of the \'clipspace limitation\' of every webgl application. The vertex shaders must reduce all geometry into unit space, including the Z dimension. This means all shapes and positions are divided so as to fit reasonably into the space of -1 to 1, for each dimension. This is a feature of *gl, so as to be able to efficiently \'clip\' unused geometry. Shrinking geometry into unit space, while creating the illusion of a large area has the tradeoff of floating point errors on the small scale, such as z-fighting / artifacts. So to avoid such errors, a space of 10,000 units is generally made available by this API. With the default (center-oriented) camera, this is seldom a problem, but using the mobile/FPS camera it\'s very easy to \'leave\' the clip space, which requires the programmer to anticipate and provide for some \'recentering\' or \'space tiling\' approach. Be aware, if the camera moves sufficiently far from the origin, the geometry may disappear due to leaving the apportioned space.\n\n### Additional Properties Exposed by LoadFPSControls\n\nAs mentioned, the camera config options (``flymode``, ``showCrosshair``, etc.) are attached to the ``renderer`` object passed to ``LoadFPSControls``, but additionally, some other helpful properties are attached as well:<br>\n``renderer.keys`` is an array of bools (true/false) with 256 elements corresponding to the ASCII keyCode of keyboard inputs. This array is updated by the API with a listener, and is created when ``LoadFPSControls`` is invoked. In your animation loop you may check key states, e.g.:\n\n```js\nrenderer.keys.map((v, i) => {\n  if(v) switch(i){\n    case 32:\n      console.log(\'spacebar down\')\n    break\n  }\n})\n```\n\nAnother useful property is ``renderer.lastInteraction``, which shows the last ``renderer.t`` value at which user input was received by mouse or keyboard. This is good for detecting and acting on \'idleness\', e.g., in your loop:\n\n```js\nif(renderer.t - renderer.lastInteraction > 60){\n  console.log(\'user has been idle for 1 minute!\')\n}\n```\n\nLastly, jumping, gravity, and other assumptions about the environment are not provided at this time. For game development approaches, the developer will need to bring in their own methods.\n<br>\n<br>\n\n## Lighting\n\n### Ambient Light\n\n``ambientLight: [0 to ...]``<br>\nAmbient light is available, optionally, as a parameter for shader instances, or globally as a Renderer parameter. If the renderer parameter is set, it will be overridden by a shader setting.<br>\n\n### Point Lights\n\nPoint lights are invoked as a shapeType (``\'point light\'``), displayed optionally in scene with a default sprite, when the property is set ``showSource: true``. the ``color`` property describes the emmissive light color. ``lum`` sets the light power. ``size`` sets the sprite size, if used. ``map`` overrides the default sprite with a custom sprite texture, alpha supported. more below.\n<br><br>\n\n## Other Methods\n\n\n### AnimationLoop()\n``Coordinates.AnimationLoop( renderer, \'Draw\' )``<br>\n##### Returns nothing. Takes no options\nThe function named should be a<br>\nwindow global  ``window.Draw = () => { ... }``, as to be callable\n<br><br>\n\n### BasicShader()\n``Coordinates.BasicShader(renderer, shaderOptions)``<br>\n\n##### Returns basic shader object, optional async\n```js\nvar shaderOptions = {\n  { lighting:\n    { type:  \'ambientLight\',  // only ambientLight type is available at this time.\n                              // if set, overrides renderer ambientLight. \n      value: [0 to 1]         // may be over/under clocked\n    }\n  },\n  {\n    uniform: { // phong shader\n      enabled: true,      // may be toggled live, with other options\n      type: \'phong\',      // pseudo-lighting effect\n      value: .3,          // intensity\n      theta: .6,          // angle in radians about the horizontal\n                          // (~4 oclock, default)\n      flatShading: false,\n    },\n  },\n  {\n    uniform: { // reflection shader\n      enabled: true,\n      type: \'reflection\', // reflect an image on shape surfaces.\n                          // works best with \'equirectangular\' maps\n      map: \'https://example.com/image.jpg\',\n          // required. URL to an image or video (web formats accepted)\n          // \"power of 2\" (64, 128, 256 etc.) width & height\n          // makes it load directly, or it will be\n          // resized in the background for drawing\n          // performance, with a load-time hit\n          // \"po2\" is required by *gl for texture wrapping\n      value: .5,  // intensity. range: 0 = invisible, to 1 = total, may be over/under clocked\n      flatShading: false,\n    }\n  }\n}\n```\n<br><br>\n\n### LoadGeometry()\n``Coordinates.LoadGeometry( renderer, geoOptions )``<br>\n\n##### Returns a mesh object, optional async\n<br>\n\n### DestroyGeometry()\n``Coordinates.DestroyGeometry( geometry)``<br>\nDestroy any references to shapes created with ``LoadGeometry``.\nCurrently applies to lights only, which are the only system-side data\nstored when geometry is created.\n\n<br>\n\n#### a note about lighting\nAn object returned by ``LoadGeometry`` is not kept in system memory. You are expected to create a data structure for managing shapes, without which they have no permanency. A geometry, especially if \'connected\' to a shader, is a whole, drawable entity and no special GC (garbage collection) work is required, since they are not stored. The only exception is lights, which are queued internally so that the scene is influenced by them. To remove a light, use the ``DestroyGeometry(shape)`` method, which removes the light source, but not your own reference to it, if any. Recall a light may be visible in your scene with the `showSource: true` property setting, and the shape returned by LoadGeometry (a rectangle) is not stored system-side, and will remain visible after the light is destroyed. You may use, for example if your shapes are in an array named \'shapes\' and your light is named \'my light\': ``shapes = shapes.filter(v=>v.name != \'my light\')`` to remove the shape from your array.\n<br>\n\n```js\nvar geoOptions = {\n  name: \'background\',  // optional name for object\n  x: 0, y: 0, z: 0,    // initial coordinates\n  roll: 0,             // orientation / rotation\n  pitch: 0,\n  yaw: 0,\n  rotationMode: 0,     // options are 0, 1, or 2, representing the order of axes a shape is rotated about.\n                       // this is useful for situations when the default results in incorrect rotations,\n                       // e.g. when the FPS camera is used.\n                       // 0 is yaw, then pitch, then roll  (normal rotation)\n                       // 1 is pitch, then yaw, then roll  (shapes that rotate in an FPS env)\n                       // 2 is roll, then pitch, then yaw  (needed rarely if ever)\n  scaleX: 1,           // resize (at creation)\n  scaleY: 1,\n  scaleZ: 1,\n  flipX:  false,       // flip vertices along this axis (at creation)\n  flipY:  false,       \n  flipZ:  false,       \n  offsetX: 0,          // set a buffer to be run on GPU (\'geometry.offsets\')\n  offsetY: 0,          \n  offsetZ: 0,          \n  scaleUVX: 1,         // resize uvs (at creation), useful for tiling,\n                       // or un-tiling textures.\n  scaleUVY: 1,         // e.g. scaleUVX:3, scaleUVY:3, -> tiles map x 3.\n                         // some maps may not tile well!\n  offsetUVX: 1,        // \'slide\' texture right/left. one unit +/- is the \n                       // texture width, wrapped.\n  offsetUVY: 1,        // \'slide\' texture up/down. one unit +/- is the\n                       // texture height, wrapped.\n                       // note: offsetting uvs is performed before scaling.\n  map: \'\',             // optional texture, URL to an image, or video.\n                         // for videos, use ``muted: false`` to prompt\n                         // the user to play audio, if desired.\n  equirectangular: false,  // if enabled, textures are assumed to be spherical.\n                           // for example, setting equirectangular: true for a\n                           // cube wraps the texture around it, versus repeating it\n                           // per face.\n  heightMap: \'\',       // a geometry modifier texture [image/canvas/video].\n  heightMapIsCanvas: false,  // if a canvas is used for the heightMap, this must be\n                             // set to true.\n  heightMapIntensity: 1,   // if a heightMap is used, this defines the distance from\n                           // zero (in the direction of normals) that the geometry\n                           // is deformed.\n  equirectangularHeightmap: false, // same as \'equirectangular\' for a map, but\n                                   // for only the heightMap.\n  color: 0x333333,     // optional color\n  colorMix: .5,        // weight of the color, to mix with texture\n  playbackSpeed: 1.0,  // if the texture (map) is a video, adjust the speed (.1 to 10)\n  canvasTexture: can,  // shapes accept canvases as textures, which are read\n                       // dynamically at draw time, allowing for animated textures.\n                       // see the example below, for useage.\n  canvasTextureMix: 1, // If a canvas is provided as a texture, this is the amount \'mixed\' with the\n                       // ordinary texture (\'map\'), if one is also provided.\n                       // note: reflections, color, textures, and canvasTextures may all be used together.\n  wireframe: false,    // if true, display shape as lines\n  exportShape: false,  // exports any shape to its fast-loading, internal format,\n                       // the exported data can be saved into files and re-loaded\n                       // with as \'custom shape\' type. \'exported\' shapes are\n                       // displayed on-screen with copy-to-clipboard buttons.\n  downloadShape: false,// same as \'exportShape\', but file(s) are downloaded instead\n                       // of displayed on screen.\n  sphereize: 1,        // interpolate a polyhedron to a sphere (=1), and beyond\n                         // read more below about this feature\n  averageNormals: false, // generate/recompute normals for any shape @ load\n  size: 1,             // not required, but the default may not be appropriate.\n  subs: 0,             // subdivides a polyhedron above, creating exponentially\n                       // more polygons/faces. Advise no more than 4!\n  shapeType: \'\'    // required.\n                   // supported types:\n                       â€¢ \'tetrahedron\'\n                       â€¢ \'cube\'\n                       â€¢ \'octahedron\'\n                       â€¢ \'dodecahedron\'\n                       â€¢ \'icosahedron\'\n                       â€¢ \'rectangle\'\n                         // is a squre, unless scaled\n                       â€¢ \'sprite\'\n                         map: [url] (required)\n                         alpha: 0-1 // supports alpha channel (png source)\n                         size: 1.0 (squre, always camera-facing)\n                         subs: 0 - 5 (poly subdivisions, for finer resolution)\n                      // LIGHTS\n                         //- other objects require phong shader for\n                         //  lights to affect them, except for\n                         //  ambient light\n                       â€¢ \'point light\'\n                         // is both a \'sprite\' (optionally) and a light source.\n                         // may have up to 16 in a scene.\n                         // has optional parameters, in addition to sprite params:\n                              lum : 0.0 to ...\n                              color: 0xffffff e.g.\n                              showSource: true/false\n                              // ignores shader, if one is connected\n                       â€¢ \'cylinder\'\n                       â€¢ \'torus\'\n                       â€¢ \'torus knot\'\n                         // cylinder, torus [knot] accept \'rows\' and \'cols\', optionally. if omitted, high-res\n                         // shapes are quick-loaded. recommend zero subs,\n                         // omit rows/cols unless custom shape is needed.\n                         // Or export a custom shape & load it as such.\n                       â€¢ \'obj\'\n                       â€¢ \'custom shape\',\n                         // \"custom shapes\" may be obtained from any\n                         // shape, by enabling the \'exportShape\' option.\n                         // These files may then be loaded via the\n                         // shapeType \'custom shape\', and \'url\', which\n                         // is streamlined for the fastest load times\n                       â€¢ \'dynamic\',\n                         // The \'dynamic\' shape type is used when geometry is\n                         // expected to change during render, as in animations\n                         // with deformable shapes. Note: every Coordinates\n                         // shape, dynamic or not, has these exposed buffers:\n                         // `shape.vertices`,\n                         // `shape.uvs`,\n                         // `shape.normalVecs`, and\n                         // `shape.normals`.\n                         //  These can be modified, for any shape, but \'dynamic\' shapes\n                         //  bypass any pre-built methods, creating empty buffers\n                         //  and allow the inclusion of geometric data via the\n                         //  LoadGeometry option: \'geometryData\', and\n                         //  \'texCoords\' (optionally). These properties expect\n                         //  data in the following structure:\n                         //  geometryData: [  // object/shape\n                         //    [              // face/polygon\n                                 [X,Y,Z], [X,Y,Z], [X,Y,Z], ... // vertices\n                         //    ], ...\n                         //  ],\n                         //  texCoords: [    // object/shape\n                         //    [              // face/polygon\n                                 [U, V], [U, V], [U, V], ... // UVs per vertex\n                         //    ], ...\n                         //  ],\n                         // Considerations: triangles may be used of course, but quads\n                         // 5-gons, and even 6-gons are accepted. Higher-point geometry\n                         // (>6) may result in undefined behavior, and 3-6 are all\n                         // converted to 3-gons, except quads. Like any shape\n                         // returned by the LoadGeometry method, buffers are\n                         // not references to the original data, but new, contiguous,\n                         // buffer-style, packed Float32 arrays. When reading/modifying\n                         // these buffers, vertices appear in 3\'s (X,Y,Z), without\n                         // labels or separation. E.g. shp.vertices = [X,Y,Z,X,Y,Z...]\n                         // There are 2 shape buffers for normals: \'normals\', and\n                         // \'normalVecs\'. The former are 6-element-stride arrays,\n                         // e.g. [X1,Y1,Z1,X2,Y2,Z2, X1,Y1,Z1,X2,Y2,Z2, ...],\n                         // with an assumed start and end point for drawing normal\n                         // lines in their spatial positions. \'normalVecs\' are proper\n                         // vectors, for use in the shader. Note that \'normals\' are not\n                         // automatically re-computed, unless requested. For this\n                         // purpose there is the exposed method \'Normal(facet)\', and\n                         // SyncNormals(shape, averageNormals=false), which\n                         // will recalculate all normals & normalVecs, optionally\n                         // averaging them with a significant performance cost.\n                         // Example:\n                         //   shape.vertices[212] -= .2         (why not?)\n                         //   Coordinates.SyncNormals(shape, true) \n                         //      //(reflections fixed!)\n                         // \n                         // Lastly, SyncNormals() can and will generate\n                         // new normals for the supplied shape. All shape types offer\n                         // access to this method, if the property is set:\n                         // `preComputeNormalAssocs: true`, but for \'dynamic\' shapes\n                         // it is automatically available.\n                       â€¢ \'particles\',\n                         // The \'particles\' shape type is just like \'dynamic\'\n                         // (above), except vertices are drawn as points. The\n                         // number of particles drawn is the number supplied in the\n                         // geometryData array passed to LoadGeometry.\n                         // Relevant particle properties:\n                         size: [0 to ...],  // max size limited by your GPU.\n                                             // check max point size.\n                                             // particle sizes are influenced by\n                                             // perspective / renderer.fov\n                         scaleX|Y|Z: particle field is scaled @ creation.\n                         color: [standard / hex, e.g. 0xff0000 (red) ],\n                                // recall functions, e.g. HexFromHSV(0, 1, 1) (red)\n                         alpha:    [0 to 1],\n                         penumbra: [0 to 1, optional \'halo\' alpha value],\n                         // considerations: each collection of particles is\n                         // contained as a single shape buffer. To manipulate individual \n                         // particles, it is much more performant to access / modify the\n                         // data via geometry.vertices, than to have many separate \'shapes\'\n                         \n                       â€¢ \'lines\',\n                         // The \'lines\' shape type is just like \'particles\'\n                         // (above), except vertices are drawn as pairs with even numbered\n                         // vertices the beginning of line segments, ending with the following\n                         // vertex. A geometryData array is expected, as with particles.\n                         // Relevant \'lines\' properties:\n                         size: [0 to ...],  // no max size, as lines are rendered as polygons.\n                                             // sizes are influenced by\n                                             // perspective / renderer.fov\n                         scaleX|Y|Z: line field is scaled @ creation.\n                         color: [standard / hex, e.g. 0xff0000 (red) ],\n                                // recall functions, e.g. HexFromHSV(0, 1, 1) (red)\n                         alpha:    [0 to 1],\n                         penumbra: [0 to 1, optional \'halo\' alpha value],\n                         // considerations: each collection of lines is\n                         // contained as a single shape buffer. To manipulate individual\n                         // lines, it is much more performant to access / modify the\n                         // data via geometry.vertices, than to have many separate \'shapes\'\n                         \n  exportShape: false, // display popup for each geometry which has this option\n  objX: 0,            // for \'obj\' or \'custom shape\' format models, initial offset\n  objY: 0,\n  objZ: 0,\n  objRoll: 0,         // for \'obj\' or \'custom shape\' format models, orient/rotate\n  objPitch: 0,\n  objYaw: 0,\n                      // enabled, to copy its raw data for later import as a\n                      // \'custom shape\'.\n  flipNormals: false,    // invert normals\n  url: \'\',               // url for \'OBJ\' format, or \'custom shapes\'.\n                         // url is ignored otherwise.\n  showBounding: false,       // use an overlaying canvas to show the bounding perimeter\n                             // of a shape or particle cluster. This property may be set\n                             // at any time, or called manually with the \n                             // Coordinates.ShowBounding() method - example below\n  boundingColor: 0x88ff22    // change/set the bounding color\n}\n```\n<br><br>\n\n### geometry.sphereize = [value]\nThis value, when set as an option for LoadGeometry, interpolates a polyhedron\nbetween its normal shape (e.g. a cube), and sphere. A value of 0 (zero) is the\nshape\'s original, expected appearance, and 1 is a sphere. Values less than zero\nor more than 1 are accepted. NOTE! if sphereize is used, you should set\n``averageNormals: true``, to recompute the data used by reflections, lighting etc.\n<br><br>\n\n### ConnectGeometry()\nPerforms linkage between geometry created with the ``LoadGeometry`` method, and a shader created with the ``BasicShader`` method. If not called, <b>Coordinates</b> will use a null shader (no effects) so the shape can be drawn. Connecting geometry to a shader removes it from any previous connections.\n\n``shader.ConnectGeometry( geometry )``\n\n##### Returns nothing, optional async\n<br><br>\n\n### Clear()\nClears the viewport.<br>\nNote: WebGL \"swaps\" buffers by default, resulting<br>\nin the clearing of drawn elements, but not the background. This clears<br>\nthe background as well. See Renderer option \'clearColor\', to set the color.<br>\n\n``renderer.Clear()``\n\n##### Returns nothing\n<br><br>\n\n### Draw()\nDraws a single geometry created with the ``LoadGeometry`` method<br>\n\n``renderer.Draw(geometry)``\n\n##### Returns nothing\n<br><br>\nThese color helper methods are also exposed\n```js\n  HSVToHex\n  HexFromHSV\n  HSVToRGB\n  RGBFromHSV\n  HexFromRGB\n  RGBToHex\n  RGBFromHex\n  HexToRGB\n```\nexample:<br>\n```js\nvar geoOptions = {\n  shapeType: \'cube\',\n  //...\n  color: Coordinates.HexFromHSV(180, 1, 1),  //teal\n  //...\n}\n```\n\n<br><br>\n\n## Animations\n\n### LoadAnimationFromZip()\nAnimations may be loaded via zip-format archives, with some options shown below:<br>\n``LoadAnimationFromZip(renderer, options, shader)``\n<br>\n\n``options`` is passed in the exact same way as a geoOptions object gets passed to the LoadGeometry method (see above). properties are applied to the contents of the zip file as if they were loaded individually.<br>\n\nNotes:<br>\n1) a ``url`` is required, pointing to a zip file.\n2) ``shapeType`` is required, same as with calls to ``LoadGeometry``\n3) zip-file contents must exist in the archive root as files, with a single format/shapeType\n4) ``downloadShape`` will optionally download a zip archive of the shape(s), after being converted to the ``custom shape`` format, for all files in the zip file. Alternatively, ``exportShape`` will display these on screen with an option to copy it.\n5) the ``name`` provided in options, will be prepended to downloaded file-names.\n6) the object returned by this method is just an array of shapes/geometries, which may be passed into the ``DrawAnimation`` method\n\n<br>\n\n### DrawAnimation()\nA companion method may be used to render the array returned by ``LoadAnimationFromZip`` :\n<br>\n\n``DrawAnimation(renderer, options, shader)``\n\n``options`` isn\'t required, but may include these properties which are applied to all frames\n```js\nvar options = {\n  x: 0, y: 0, z: 0,\n  roll: 0, pitch: 0, yaw: 0,\n  loopMode: \'reverse\',\n  animationSpeed: 1,\n}\n```\n\nNotes:<br>\n``loopMode`` may be \'reverse\', \'cycle\', or omitted. the former runs the animation forward and then backward, looping while the latter loops from the first frame. ``reverse`` is the default.<br>\n``animationSpeed`` is self explanatory, with an expected range of 0.0 to 1.0, from stopped to advancing +1 frame per call, with fractional values reflecting frequencies in between.\n<br><br>\n\n#### Animation Usage Example:\n```js\nvar renderer = await Coordinates.Renderer({margin: 0})\nCoordinates.AnimationLoop(renderer, \'Draw\')\n\nvar refTexture = \'https://srmcgann.github.io/Coordinates/resources/spectrum_test_tile.jpg\'\n\nvar shaderOptions = [\n  { lighting: {type: \'ambientLight\', value: .3 } },\n  { uniform: {\n    type: \'phong\',\n    value: .5\n  } },\n  { uniform: {\n    type: \'reflection\',\n    map: refTexture,\n    value: .25,\n  } }\n]\nvar shader = await Coordinates.BasicShader(renderer, shaderOptions)\n\nconst baseURL = \'https://srmcgann.github.io/Coordinates\'\nvar geoOptions = {\n  shapeType: \'custom shape\',\n  url: baseURL + \'/zip animations/demoAnimation.zip\',\n  map: baseURL + \'/resources/nebugrid_po2.jpg\',\n  equirectangular: true,\n  colorMix: 0,\n}\nvar animation = await Coordinates.LoadAnimationFromZip(renderer, geoOptions, shader)\n\nvar background\nvar geoOptions = {\n  shapeType: \'dodecahedron\',\n  size: 1e3,\n  subs: 2,\n  colorMix: 0,\n  map: refTexture\n}\nawait Coordinates.LoadGeometry(renderer, geoOptions).then( geometry => {\n  background = geometry\n})\n\nrenderer.z = 10\n\nwindow.Draw = () => {\n  Coordinates.DrawAnimation(renderer, animation, {pitch: renderer.t})\n  renderer.yaw += .01\n  renderer.roll += .007\n  renderer.pitch += .005\n  renderer.Draw(background)\n}\n```\n\nThis creates such output<br>\n<center>\n\n![example2](https://srmcgann.github.io/Coordinates/img/README_g6.gif) </center>\n', 'pCthTgx6f', 0, '2025-10-02 19:49:02', '2025-10-02 19:49:02', 11),
(5712182234181411, 'Fog', 1, '# fog\n<iframe style=\"width: 480px; height: 270px; border: none; border-radius: 10px;\" src=\"https://srmcgann.github.io/Coordinates/examples/fogAndShapeArray.html\"></iframe>\n\nfog may be added to a scene\n- invoke it in a shader config\n- connect the shader object to a shape/geometry\n```js\nvar shaderOptions = [\n  // ...\n  { uniform: {\n    type: \'fog\',\n    color: fogColor,  // hex value, e.g. 0x222222 (dark grey)\n    value: 5.5        // fog \'thickness\' or distance. 0 - ∞\n  } }\n]\nvar shader = await Coordinates.BasicShader(renderer, shaderOptions)\n```\n\n<br>\nfull example\n```js\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>fog / shape array example</title>\n    <style>\n      body, html{\n        background: #000;\n        margin: 0;\n        min-height: 100vh;\n        overflow: hidden;\n      }\n    </style>\n  </head>\n  <body>\n    <script type=\"module\">\n    \n      import * as Coordinates from\n      \"https://srmcgann.github.io/Coordinates/coordinates.min.js\"\n    \n      var fogColor = 0x333333\n      var rendererOptions = {\n        ambientLight: 4, margin: 0,\n        fov: 1400, clearColor: fogColor\n      }\n      var renderer = await Coordinates.Renderer(rendererOptions)\n      \n      var S  = Math.sin\n      var C  = Math.cos\n      var Rn = Math.random\n      \n      Coordinates.AnimationLoop(renderer, \'Draw\')\n\n      var shaderOptions = [\n        { uniform: {\n          type: \'phong\',\n          value: 1\n        } },\n        { uniform: {\n          type: \'fog\',\n          color: fogColor,\n          value: 5.5\n        } }\n      ]\n      var shader = await Coordinates.BasicShader(renderer, shaderOptions)\n\n      var shapes = []\n      var geoOptions = {\n        shapeType: \'octahedron\',\n        subs: 2,\n        sphereize: -.75,\n        averageNormals: true,\n        size: 1,\n        color: 0xffffff,\n      }\n      await Coordinates.LoadGeometry(renderer, geoOptions).then(async (geometry) => {\n        var p\n        var ar\n        ar = Array(10).fill().map((v, i) => [S(p=Math.PI*2/10*i)*5, C(p)*5, 0])\n        Coordinates.ShapeFromArray(geometry, ar, {\n          y: 2,\n          color: 0x00ff44,\n          name: \'centris\',\n        }).then(async res => {\n          shapes.push(res)\n          await shader.ConnectGeometry(res)\n        })\n        ar = Array(100).fill().map((v, i) => [\n          ((i%10)-5+.5) * 3, -4, ((i/10|0)-5+.5) * 3,\n        ])\n        Coordinates.ShapeFromArray(geometry, ar, {\n          name: \'floor\',\n          color: 0x4400ff,\n        }).then(async res => {\n          shapes.push(res)\n          await shader.ConnectGeometry(res)\n        })\n      })  \n      \n      \n      window.Draw = () => {\n        renderer.Clear()\n        var t = renderer.t\n        renderer.z = 9\n        shapes.forEach(shape => {\n          switch(shape.name){\n            case \'floor\':\n              shape.yaw = t/2\n            break\n            default:\n              shape.roll = t\n              shape.pitch = t + Math.PI/2\n              shape.yaw = t*2\n            break\n          }\n          renderer.Draw(shape)\n        })\n      }\n      \n    </script>\n  </body>\n</html>\n```\nthis produces such output\n\n<iframe style=\"width: 480px; height: 270px; border: none; border-radius: 10px;\" src=\"https://srmcgann.github.io/Coordinates/examples/fogAndShapeArray.html\"></iframe>\n', 'qa2aDkhV1', 0, '2025-08-13 00:27:52', '2025-08-13 00:27:52', 35);
INSERT INTO `projects` (`id`, `name`, `userID`, `data`, `slug`, `private`, `created`, `updated`, `views`) VALUES
(8211469839537136, 'importing / exporting', 1, '# importing and exporting\na variety of formats are supported for convenience. internally, the API uses flat packed buffers\n\nshapes will commonly include these arrays\n\n* `vertices` (always included, stride=3)\n* `normals` (used to draw normal lines graphically with `showNormals: true`, optional, stride = 2x3 = 6)\n* `normalVecs` (actual normals used for shading, optional, stride = 3)\n* `uvs` (texture coordinates, optional, stride = 2)\n* `normalAssocs` (uncommon. binding associations for coincidental verts. implemented automatically for the dynamic shapeType and allows for fast updating of normals without needing to re-average them at draw-time.\n\n<br>\nthe `shapeType: \'custom shape\'` format may be imported or exported directly as clear text JSON containing literally the arrays shown above.\n\n<br>\n* To import a custom shape, a file URL may be given via the `url: \'https://example.com/file.json\'` geometry option.\n```js\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>Coordinates boilerplate example</title>\n    <style>\n      body, html{\n        background: #000;\n        margin: 0;\n        min-height: 100vh;\n        overflow: hidden;\n      }\n    </style>\n  </head>\n  <body>\n    <script type=\"module\">\n    \n      import * as Coordinates from\n      \"https://srmcgann.github.io/Coordinates/coordinates.min.js\"\n    \n      var renderer = await Coordinates.Renderer({clearColor: 0x441122})\n      \n      Coordinates.AnimationLoop(renderer, \'Draw\')\n\n      var shaderOptions = [\n        {lighting: {type:\'ambientLight\', value: .5}},\n        { uniform: {\n          type: \'phong\',\n          value: .25\n        } }\n      ]\n      var shader = await Coordinates.BasicShader(renderer, shaderOptions)\n\n\n      var shapes = []\n      var baseURL = `https://srmcgann.github.io/Coordinates/custom shapes/flower 1/`\n      var geoOptions = {\n        shapeType: \'custom shape\',\n        url: `${baseURL}flower 1.json`,\n        map: `${baseURL}/flower 1 texture 4_lowres.jpg`,\n        colorMix: 0,\n        scaleX: 8,\n        scaleY: 5,\n        scaleZ: 8,\n        objY: -3\n      }\n      await Coordinates.LoadGeometry(renderer, geoOptions).then(async (geometry) => {\n        shapes.push(geometry)\n        await shader.ConnectGeometry(geometry)\n      })  \n      \n      window.Draw = () => {\n        renderer.z = 4\n        renderer.Clear()\n        shapes.forEach((shape, idx) => {\n          \n          for(var m = 3; m--; ){\n            shape.yaw = renderer.t*(m%2?2:-2)\n            shape.x     = -4+m*4\n            shape.roll  = Math.cos(renderer.t+idx)/8\n            shape.pitch = .75 + Math.cos(renderer.t/2+Math.PI/3*m) / 2\n            renderer.Draw(shape)\n          }\n        })\n      }\n      \n    </script>\n  </body>\n</html>\n```\nthis complete example produces such a result\n<iframe style=\"width: 480px; height: 270px; border: none; border-radius: 10px;\" src=\"https://srmcgann.github.io/Coordinates/examples/CustomShapes.html\"></iframe>\n\nThere are a lot of public domain `custom shape` type models available in the main API repository, in the \'custom shapes\' folder. These may all be used freely in projects. No guarantees are extended as to availability, performance, or problems they may cause.\n\n<br>\non the next page: exporting to a custom shape file\n<pagebreak>\n# exporting to `custom shape`\nsince the custom shape format is essentially the same flat packed buffer used internally, loading is extremely fast, given a fast internet connection. Any host of your choosing may be used to serve the files, including github.com.\n\nTo export to `custom shape`, the file contents may be copied on screen by setting `exportShape: true` in the geometry options, or downloaded as a stand alone file with the name (or type, if unnamed) of the shape, by setting `downloadShape: true`. Multiple shapes may be downloaded or exported simultaneously.\n\nexample\n```js\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>Coordinates boilerplate example</title>\n    <style>\n      body, html{\n        background: #000;\n        margin: 0;\n        min-height: 100vh;\n        overflow: hidden;\n      }\n    </style>\n  </head>\n  <body>\n    <script type=\"module\">\n    \n      import * as Coordinates from\n      \"https://srmcgann.github.io/Coordinates/coordinates.min.js\"\n    \n      var renderer = await Coordinates.Renderer()\n      \n      renderer.z = 8\n      Coordinates.AnimationLoop(renderer, \'Draw\')\n\n      var shaderOptions = [\n        { uniform: {\n          type: \'phong\',\n          value: .75\n        } }\n      ]\n      var shader = await Coordinates.BasicShader(renderer, shaderOptions)\n\n\n      var shapes = []\n      var geoOptions = {\n        shapeType: \'dodecahedron\',\n        size: 5,\n        color: 0xffffff,\n        exportShape: true,\n        downloadShape: true,\n      }\n      await Coordinates.LoadGeometry(renderer, geoOptions).then(async (geometry) => {\n        shapes.push(geometry)\n        await shader.ConnectGeometry(geometry)\n      })  \n      \n      window.Draw = () => {\n        shapes.forEach(shape => {\n          shape.yaw += .01\n          shape.pitch += .005\n          renderer.Draw(shape)\n        })\n      }\n\n    </script>\n  </body>\n</html>\n```\nwhich produces this result, including a downloaded file per the config shown\n<iframe style=\"transform: scale(.6, .6); width: 800px; height: 450px; border: none; border-radius: 10px;\" src=\"https://srmcgann.github.io/Coordinates/examples/downloadCustomShape.html\"></iframe>\n\n<br>\non the next page: OBJ format\n\n<pagebreak>\nthe `shapeType: \'obj\'` format may be imported or exported directly as clear text OBJ. Full support is still in development for extended OBJ features like materials, smoothing groups, lines, etc., but basic geometry is supported for import and export. Note that the API supports OBJ models with UVs, and texture maps can be used normally eliminating the need to rely on the OBJ material system.\n\n<br>\n* To import an OBJ shape, a file URL may be given via the `url: \'https://example.com/file.obj\'` geometry option.\n```js\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>Coordinates boilerplate example</title>\n    <style>\n      body, html{\n        background: #000;\n        margin: 0;\n        min-height: 100vh;\n        overflow: hidden;\n      }\n    </style>\n  </head>\n  <body>\n    <script type=\"module\">\n    \n      import * as Coordinates from\n      \"https://srmcgann.github.io/Coordinates/coordinates.min.js\"\n    \n      var renderer = await Coordinates.Renderer({clearColor: 0x114488})\n      \n      Coordinates.AnimationLoop(renderer, \'Draw\')\n\n      var shaderOptions = [\n        {lighting: {type:\'ambientLight\', value: .7}},\n        { uniform: {\n          type: \'phong\',\n          value: .4\n        } }\n      ]\n      var shader = await Coordinates.BasicShader(renderer, shaderOptions)\n\n\n      var shapes = []\n      var baseURL = `https://srmcgann.github.io/objs/mountain/`\n      var geoOptions = {\n        shapeType: \'obj\',\n        url: `${baseURL}mountain_medpoly.obj`,\n        map: `${baseURL}mountain.jpg`,\n        colorMix: 0,\n        scaleX: 4,\n        scaleY: 4,\n        scaleZ: 4,\n      }\n      await Coordinates.LoadGeometry(renderer, geoOptions).then(async (geometry) => {\n        shapes.push(geometry)\n        await shader.ConnectGeometry(geometry)\n      })  \n      \n      window.Draw = () => {\n        renderer.z = 4\n        renderer.Clear()\n        shapes.forEach((shape, idx) => {\n          \n          for(var m = 3; m--; ){\n            shape.yaw = renderer.t*(m%2?2:-2)\n            shape.x     = -4+m*4\n            shape.y     = -1.5\n            shape.roll  = Math.cos(renderer.t+idx)/8\n            shape.pitch = .3 + Math.cos(renderer.t/2+Math.PI/3*m) / 3\n            renderer.Draw(shape)\n          }\n        })\n      }\n      \n    </script>\n  </body>\n</html>\n```\nthis complete example produces such a result\n<iframe style=\"width: 480px; height: 270px; border: none; border-radius: 10px;\" src=\"https://srmcgann.github.io/Coordinates/examples/ImportOBJ.html\"></iframe>\n\nOBJ is a common format, and many sites, applications, and tools use it natively.\n\n<br>\non the next page: exporting to the OBJ format\n<pagebreak>\n# exporting to `obj`\n\nTo export to `obj`, the file contents may be copied on screen by setting `exportAsOBJ: true` in the geometry options, or downloaded as a stand alone file with the name (or type, if unnamed) of the shape, by setting `downloadAsOBJ: true`. Multiple shapes may be downloaded or exported simultaneously.\n\nexample\n```js\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>Coordinates boilerplate example</title>\n    <style>\n      body, html{\n        background: #000;\n        margin: 0;\n        min-height: 100vh;\n        overflow: hidden;\n      }\n    </style>\n  </head>\n  <body>\n    <script type=\"module\">\n    \n      import * as Coordinates from\n      \"https://srmcgann.github.io/Coordinates/coordinates.min.js\"\n    \n      var rendererOptions = {\n        ambientLight: .5,\n        fov: 1500\n      }\n      var renderer = await Coordinates.Renderer(rendererOptions)\n      \n      renderer.z = 8\n      Coordinates.AnimationLoop(renderer, \'Draw\')\n\n      var shaderOptions = [\n        { uniform: {\n          type: \'phong\',\n          value: .75\n        } }\n      ]\n      var shader = await Coordinates.BasicShader(renderer, shaderOptions)\n\n\n      var shapes = []\n      var geoOptions = {\n        shapeType: \'dodecahedron\',\n        size: 5,\n        color: 0xffffff,\n        exportAsOBJ: true,\n        downloadAsOBJ: true,\n      }\n      await Coordinates.LoadGeometry(renderer, geoOptions).then(async (geometry) => {\n        shapes.push(geometry)\n        await shader.ConnectGeometry(geometry)\n      })  \n      \n      \n      window.Draw = () => {\n        shapes.forEach(shape => {\n          shape.yaw += .01\n          shape.pitch += .005\n          renderer.Draw(shape)\n        })\n      }\n      \n    </script>\n  </body>\n</html>\n```\nwhich produces this result, including a downloaded file per the config shown\n<iframe style=\"transform: scale(.6, .6); width: 800px; height: 450px; border: none; border-radius: 10px;\" src=\"https://srmcgann.github.io/Coordinates/examples/downloadOBJ.html\"></iframe> \n\nFinal notes: shapes may be arbitrarily swapped to/from any format that allows it, including the ones shown in this section. For example, a `torus` may be downloaded as a `custom shape`, re-imported then exported as an `obj`, and again back to a `custom shape` and so forth.', 'BBJwWA1Qk', 0, '2025-08-14 00:57:56', '2025-08-14 00:57:56', 22),
(8493812491758767, 'custom shaders', 1, '# custom shader\n\ncustom shaders may be loaded\n\nexample, to inject custom GLSL (e.g. frag) code\n```js\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>Coordinates custom shader example</title>\n    <style>\n      body, html{\n        background: #333;\n        margin: 0;\n        min-height: 100vh;\n        overflow: hidden;\n      }\n    </style>\n  </head>\n  <body>\n    <script type=\"module\">\n    \n      import * as Coordinates from\n        \"https://srmcgann.github.io/Coordinates/coordinates.js\"\n    \n      var renderer = await Coordinates.Renderer()\n      Coordinates.AnimationLoop(renderer, \'Draw\')\n      \n      renderer.z = 10\n\n      var shaderOptions = [\n        { uniform: {\n          type: \'phong\',\n          value: .5\n        } },\n      ]\n      var mainShader = await Coordinates.BasicShader(renderer, shaderOptions)\n\n      var shaderOptions = [\n        { uniform: {\n          type: \'phong\',\n          value: .5\n        } },\n        { uniform: {\n          type: \'custom\',\n          name: \'newColor\',\n          dataType: \'uniform4f\',\n          value: [0, 0, .5, 1],  // [red, green, blue, alpha]\n          vertDeclaration: \"\",\n          vertCode:        \"\",\n          fragDeclaration: \'uniform vec4 newColor;\',\n          fragCode:        \'mixColor = newColor;\',\n          enabled: true,\n        } }\n      ]\n      var customShader = await Coordinates.BasicShader(renderer, shaderOptions)\n        \n        \n      var cube1, cube2\n      var geoOptions = {\n        shapeType: \'cube\',\n        size: 5,\n        color: 0x880000,\n        colorMix: 1,\n      }\n      \n      await Coordinates.LoadGeometry(renderer, geoOptions).then(async (geometry) => {\n        cube1 = geometry\n        mainShader.ConnectGeometry(cube1)\n      })\n      \n      await Coordinates.LoadGeometry(renderer, geoOptions).then(async (geometry) => {\n        cube2 = geometry\n        customShader.ConnectGeometry(cube2)\n      })  \n      \n      window.Draw = () => {\n      \n        cube1.yaw += .01\n        cube1.pitch += .01\n        cube1.x = -6\n        renderer.Draw(cube1)\n        \n        cube2.yaw += .01\n        cube2.pitch += .01\n        cube2.x = 6\n        renderer.Draw(cube2)\n        \n      }\n      \n    </script>\n  </body>\n</html>\n```\nthis produces such effect\n<iframe style=\"width: 480px; height: 270px; border: none; border-radius: 10px;\" src=\"https://srmcgann.github.io/Coordinates/examples/customShader.html\"></iframe>\n', 'CTUkAzdCv', 0, '2025-08-14 00:32:20', '2025-08-14 00:32:20', 9),
(8945797165424812, 'b-spline curves', 1, '# b-spline\n<iframe style=\"width: 480px; height: 270px; border: none; border-radius: 10px;\" src=\"https://srmcgann.github.io/Coordinates/examples/BSpline_simple.html\"></iframe>\n\na spline curve may be generated from a point array\n\ncontrol points are passed via the `geometryData` property in geometry options\n\n<br>\nmethod 1, `shapeType: \'bspline\'`\n```js\nvar geoOptions = {\n  shapeType: \'bspline\',\n  geometryData: Array(5).fill().map(v => {\n    return [(Math.random()-.5)*32, (Math.random()-.5)*18, 0])\n  }),\n  alpha: 1,\n  size: 14,\n  steps: 100,\n  penumbra: .25,\n  color: 0x00ff44,\n}\nawait Coordinates.LoadGeometry(renderer, geoOptions).then((geometry) => {\n  geometry.size = 3\n  splineCurve = geometry\n})\n```\nnote: `size` as passed to `LoadGeometry` influences the whole shape size, where the `size` property of the geometry it creates controls the line thickness.\n\n\n### a more complex example with animated points\n<iframe style=\"width: 480px; height: 270px; border: none; border-radius: 10px;\" src=\"https://srmcgann.github.io/Coordinates/examples/BSpline.html\"></iframe>\n\n<br>\nmethod 2, using `Coordinates.BSpline(renderer, options)`\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>Coordinates boilerplate example</title>\n    <style>\n      body, html{\n        background: #000;\n        margin: 0;\n        min-height: 100vh;\n        overflow: hidden;\n      }\n    </style>\n  </head>\n  <body>\n    <script type=\"module\">\n    \n      import * as Coordinates from\n      \"https://srmcgann.github.io/Coordinates/coordinates.min.js\"\n    \n      var renderer = await Coordinates.Renderer()\n      var Rn = Math.random\n      \n      Coordinates.AnimationLoop(renderer, \'Draw\')\n\n      var shapes = []\n\n      var redDot\n      var geoOptions = {\n        shapeType: \'sprite\',\n        size: .5,\n        map: \'https://srmcgann.github.io/Coordinates/resources/dots/red_dot_black_border.png\',\n      }\n      await Coordinates.LoadGeometry(renderer, geoOptions).then(async (geometry) => {\n        redDot = geometry\n      })        \n      \n      var iPc = 6\n      var iPv = .5\n      var steps = 30\n      \n      var pts = {\n        positions: Array(iPc).fill().map((v, i) =>\n          [(Rn()-.5)*16, (Rn()-.5)*9, 0],\n        ),\n        velocities: Array(iPc).fill().map((v, i) =>\n          [(Rn()-.5)*iPv, (Rn()-.5)*iPv, 0],\n        ),\n      }\n      await Coordinates.BSpline(renderer, {\n        geometryData: pts.positions,\n        omitShape: true,\n        steps\n      }).then(res => {\n        var geoOptions = {\n          shapeType: \'lines\',\n          name: \'curve\',\n          alpha: .75,\n          penumbra: .25,\n          geometryData: res.curve,\n          size: 5,\n          color: 0xff0000,\n        }\n        Coordinates.LoadGeometry(renderer, geoOptions).then(async (geometry) => {\n          shapes.push(geometry)\n        })  \n      })\n      \n      \n      window.Draw = () => {\n        var t = renderer.t\n        renderer.z = 8.5\n        shapes.forEach(shape => {\n          switch(shape.name){\n            case \'curve\':\n              pts.positions.map((v, i) =>{\n                var vx = pts.velocities[i][0]\n                var vy = pts.velocities[i][1]\n                if(v[0] + vx > 16 || v[0] + vx < -16) vx = pts.velocities[i][0] *= -1\n                if(v[1] + vy > 9 || v[1] + vy < -9)  vy = pts.velocities[i][1] *= -1\n                v[0] += vx\n                v[1] += vy\n              })\n              Coordinates.BSpline(renderer, {\n                geometryData: pts.positions,\n                omitShape: true,\n                steps\n              }).then(res => {\n                for(var i = 0; i < shape.vertices.length; i+=3){\n                  var j = i/3\n                  shape.vertices[i+0] = res.curve[j][0]\n                  shape.vertices[i+1] = res.curve[j][1]\n                  shape.vertices[i+2] = res.curve[j][2]\n                }\n                res.midPoints.forEach((pt, idx) => {\n                  redDot.x = pt[0]\n                  redDot.y = -pt[1]\n                  redDot.z = pt[2] - idx/100\n                  renderer.Draw(redDot)\n                })\n                renderer.Draw(shape)\n              })\n            break\n            default:\n              renderer.Draw(shape)\n            break\n          }\n        })\n      }\n      \n    </script>\n  </body>\n</html>\n```\nnote: `omitShape: true/false` as an option passed to `Coordinates.BSpline` may optionally return a complete geometry, or just the `geometryData` for further processing, as shown here. If only the curve data is needed, it is more performant to omit the shape.\n\n<br>\nAPI pseudocode\n```\nif(geoOptions.omitShape){\n  return { curve }\n}else{\n  var ret\n  LoadGeometry(renderer, geoOptions).then(async geometry => ret = geometry )\n  return {\n    curve,\n    shape: ret,\n  }\n}\n```', 'EYfM5WaWU', 0, '2025-08-13 23:09:22', '2025-08-13 23:09:22', 25),
(8958919686759339, 'Coordinates.js (section 6)', 1, '### Intersects()\n``const Intersects = (X1, Y1, X2, Y2, X3, Y3, X4, Y4)``\n<br><br>\n``Intersects`` returns a 2D vertex of the intersection point if one exists, between 2 line segments, or false if there is no intersection.<br>\n<br><br>\nMethod requires input of 8 numbers, the endpoints of the line segments in the order Pa1, Pa2, Pb1, Pb2.\n<br><br>\nexample:\n```js\nvar X1 = -.5\nvar Y1 = -1\nvar X2 = 1.5\nvar Y2 = 1\nvar X3 = 1.5\nvar Y3 = -1\nvar X4 = -.5\nvar Y4 = 1\nvar i = Coordinates.Intersects(X1, Y1, X2, Y2, X3, Y3, X4, Y4)\n// returned value: [ 0.5, 0]\n```\n\n<br><br>\n### PointInPoly2D()\n``const PointInPoly2D = (X, Y, polygon)``\n<br><br>\n``PointInPoly2D`` returns true if the point is inside a polygon of any number of sides.<br>\n<br><br>\nMethod requires input of 2 numbers, which is the point in question, and a polygon as an array with at least 3 vertices\n<br><br>\nexample:\n```js\nvar polygon = [ [-1.2, 0, 0],   [0, -1, 0],   [3, 1, 2] ]\nvar X = 0,  Y = 0\nvar point = Coordinates.PointInPoly2D(X,Y, polygon)\n// returned value: true\n// note: a 3D polygon may be used, but only the first 2 elements [X, Y] are involved\n```\n\n<br><br>\n### PointInPoly3D()\n``const PointInPoly3D = (X1, Y1, Z1, X2, Y2, Z2, polygon)``\n<br><br>\n``PointInPoly3D`` returns the intersection point, if any (or false), of a line segment and polygon in 3 dimensions.<br>\nFor convenience, the normal of the polygon is also returned as a second element.\n<br><br>\nMethod requires input of 6 numbers, which are the 2 end points of a line-segment in 3D space (2x3=6) and a polygon as an array with at least 3 vertices\n<br><br>\nexample:\n```js\nvar polygon = [ [-1.2, 0, 0],   [0, -1, 0],   [3, 1, 2] ]\nvar X1 = .5,  Y1 = -.5,  Z1 = 3\nvar X2 = .2,  Y2 = .2,   Z2 = -1\nvar point = Coordinates.PointInPoly3D(X1,Y1,Z1,  X2,Y2,Z2,  polygon)\n// returned value: point, normal ->\n  [\n      [\n          0.3148953466981546,\n          -0.067901234567901,\n          0.530894024154322\n      ],\n      [\n          0.3205339025930031,\n          0.38464068311160365,\n          -0.8654415370011083\n      ]\n  ]\n// note: returns false if no intersection exists\n```\n\n<br><br>\n### IsPowerOf2()\n``const IsPowerOf2 = (num)``\n<br><br>\n``IsPowerOf2`` returns a true if the input number is a valid power of 2, or false if not.<br>\n<br><br>\nMethod requires input of 1 number.\n<br><br>\nexample:\n```js\nvar po2 = Coordinates.IsPowerOf2(3)\n// returned value: false\n\nvar po2 = Coordinates.IsPowerOf2(4)\n// returned value: true\n```\n\n<br><br>\n### GetShaderCoord()\n``const GetShaderCoord = (vx, vy, vz, geometry, renderer)``\n<br><br>\n``GetShaderCoord`` returns the rasterized [x, y(, z)] canvas coordinate of a provided vertex ``(vx, vy, vz, ...``, relative to a given shape-geometry and renderer, using their current settings. These may include things like a heightmap and/or equirectangular plugin. The returned point represents where on the 2D canvas, the 3D point will be drawn. The provided shape-geometry has a position, orientation, and possible displacement modifier(s), which are factored into the output. This method may be useful for plotting overlay graphics, or interactivity which depends on click location for example.<br>\n<br>\nMethod requires input of 3 numbers, x/y/z of a vertex, a shape-geometry object, and a renderer object.\n<br><br>\nexample:\n```js\nvar vx = geometry.vertices[0]\nvar vy = geometry.vertices[1]\nvar vz = geometry.vertices[2]\nvar px = GetShaderCoord (vx, vy, vz, geometry, renderer)\n// px = returned value [X, Y(, Z)], where the actual first vertex\n// in the shape geometry will be drawn on canvas. the z/depth\n// component is also returned.\n```\n\n<br><br>\n### Overlay\n``Coordinates.Overlay`` is a transparent 2d canvas created atop every renderer viewport by default, with matching width/height. It is used for displaying bounding outlines if they are configured, but it is exposed for other purposes as well. The Overlay is an ordinary ``Renderer`` object like any camera/renderer, but with a \'2d\' canvas type, full transparency and is auto-cleared between frames. Its context is ``Overlay.ctx``, and the element itself is ``Overlay.c``. With these, any 2d canvas operations may be performed.<br><br>\n\na complete working example:\n```js\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>Coordinates boilerplate example</title>\n    <style>\n      body, html{\n        background: #333;\n        margin: 0;\n        min-height: 100vh;\n        overflow: hidden;\n      }\n    </style>\n  </head>\n  <body>\n    <script type=\"module\">\n\n      import * as Coordinates from\n      \"https://srmcgann.github.io/Coordinates/coordinates.min.js\"\n\n      var rendererOptions = {\n        ambientLight: .5,\n        fov: 2e3,\n        z: 85\n      }\n      var renderer = await Coordinates.Renderer(rendererOptions)\n\n      Coordinates.AnimationLoop(renderer, \'Draw\')\n\n      var shaderOptions = [\n        { uniform: {\n          type: \'phong\',\n          value: .75\n        } }\n      ]\n      var shader = await Coordinates.BasicShader(renderer, shaderOptions)\n\n      var shapes = []\n      \n      var playerNum = 4, p\n      for(var i=0; i<playerNum; i++){\n        var x = Math.sin(p = Math.PI*2/playerNum*i) * 48\n        var y = Math.cos(p) * 24\n        var z = 0\n        var geoOptions = {\n          name: \'player \' + (i+1),\n          shapeType: \'cube\',\n          size: 10,\n          x, y, z,\n          color: Coordinates.HSVToHex(360/playerNum*i,1,1),\n        }\n        await Coordinates.LoadGeometry(renderer, geoOptions).then(async (geometry) => {\n          shapes.push(geometry)\n          await shader.ConnectGeometry(geometry)\n        })\n      }\n      \n      Coordinates.LoadFPSControls(renderer)\n      \n      var ctx = Coordinates.Overlay.ctx\n      \n      const strokeCustom = () => {\n        ctx.globalAlpha = .2\n        ctx.lineWidth = 10\n        ctx.stroke()\n        ctx.globalAlpha = .5\n        ctx.lineWidth = 2\n        ctx.stroke()\n      }\n\n      const drawPlayerNames = shape => {\n        var pt = Coordinates.GetShaderCoord(0,0,0, shape, renderer)\n        var rad = 60\n        ctx.fillStyle = ctx.strokeStyle = \'#0f8\'\n        ctx.beginPath()\n        ctx.arc(pt[0], pt[1],rad,0,7)\n        strokeCustom()\n        \n        var lx, ly\n        ctx.beginPath()\n        if(pt[0] > Coordinates.Overlay.c.width/2){\n          lx = -1\n          ctx.textAlign = \'right\'\n        }else{\n          lx = 1\n          ctx.textAlign = \'left\'\n        }\n        if(pt[1] > Coordinates.Overlay.c.height/2){\n          ly = -1\n        }else{\n          ly = 1\n        }\n        var d = Math.hypot(lx, ly)\n        ctx.lineTo(pt[0]+lx/d*rad, pt[1]+ly/d*rad)\n        ctx.lineTo(pt[0]+lx/d*rad*3, pt[1]+ly/d*rad*2.2)\n        ctx.lineTo(pt[0]+lx/d*rad*10, pt[1]+ly/d*rad*2.2)\n        strokeCustom()\n        \n        ctx.globalAlpha = .8\n        var fontsize = rad / 1.5\n        ctx.font = fontsize+\'px verdana\'\n        lx = pt[0]+lx/d*rad*3.5\n        ly = pt[1]+ly/d*rad*2.2\n        ctx.lineWidth = 5\n        ctx.strokeStyle = \'#000d\'\n        ctx.strokeText(shape.name, lx, ly-fontsize/6)\n        ctx.fillText(shape.name, lx, ly-fontsize/6)\n      }\n\n      window.Draw = () => {\n        shapes.forEach(shape => {\n          shape.yaw += .01\n          shape.pitch += .005\n          renderer.Draw(shape)\n          drawPlayerNames(shape)\n        })\n      }\n      \n    </script>\n  </body>\n</html>\n```\nThe code above produces this result:\n<center>\n\n![picker](https://srmcgann.github.io/Coordinates/img/README_g5.gif) </center>\n\n### GenHash()\n``Coordinates.GenHash`` accepts string data as a parameter, returning a custom, unique 32 character hash. Hashes are useful for many things, including fingerprinting of unique items which may be of arbitrary size/length.\n<br>\n\nexample:\n```js\nvar ar = [\'apples\', \'bananas\', \'peaches\']\nar = ar.map(v=>({name: v, hash: Coordinates.GenHash(v)}))\n\n/* ar ->\n[\n    {\n        \"name\": \"apples\",\n        \"hash\": \"uvxzDFJLPVX379djprxBDJNT157bdhvz\"\n    },\n    {\n        \"name\": \"bananas\",\n        \"hash\": \"LMOQUW026cekoquAGIOSU04aimosuyMQ\"\n    },\n    {\n        \"name\": \"peaches\",\n        \"hash\": \"NOQSWY248egmqswCIKQUW26ckoquwAOS\"\n    }\n] */\n\n// then, to select an item by its unique hash:\nvar match = ar.filter(v=>v.hash==\'NOQSWY248egmqswCIKQUW26ckoquwAOS\')\nif(match.length) console.log(match[0].name)\n\n// > \'peaches\'\n```', 'F1YNUKnAD', 0, '2025-10-02 19:54:59', '2025-10-02 19:54:59', 6),
(8982487228343656, 'Coordinates.js (section 5)', 1, '\n## Additional Helper Methods\n\n### R()\nCoordinates performs geometric rotations in shader for performance reasons, but there may be times when scene geometry should be modified manually, apart from shape positions and rotations, such as deforming geometry or custom rotations. The ``R`` function is exposed for this, and expects paramters as follows<br>\n``R = (X, Y, Z, {roll, pitch, yaw}, addCameraZ = false)``\n<br><br>\n``R`` returns a 3-component ( [X, Y, Z] ) array with the resulting, modified input vertex\n<br><br>example:\n```js\nvar X = 1\nvar Y = 0\nvar Z = 0\nvar ar = Coordinates.R(X, Y, Z, {0, 0, Math.PI})\n// ar -> [-1, 0, 0]\n\n```\n<br><br>\n### Normal()\nA geometric \'normal\' is vector, perpendicular to a plane or polgon. Normals are used for many purposes, including shading, reflections, and collision detection.<br>\nA method, ``Normal``, is exposed for manually computing the normal of any set of points, which are assumed to constitute a plane or flat surface of arbitrary orientation in space, usually a triangle or quad.<br>\n``Normal = (facet, autoFlipNormals=false, X1=0, Y1=0, Z1=0) ``\n<br>\n``Normal`` requires input of a 2D array of at least 3 vertices. Additionally, it may ``autoflip`` away from the origin, which may be supplied as X1, Y1, Z1, shown above, or assumed to be 0,0,0 if these are omitted.\n<br><br>\nexample:\n```js\nvar facet = [\n  [-1, 0, 0],\n  [0,  0, 1],\n  [1,  0, 0],\n]\nvar n = Coordinates.Normal(facet)\n// n -> [0,0,.33,  0,-1,.33]\n// returned vector is centered in the polygon, and has 6\n// elements, a vec3 start and end point.\n// This is for purposes of drawing vector lines, but the raw\n// vector [X, Y, Z] may be obtained by subtracting the last 3 elements\n// from the first 3, respectively. Note that meshes in Coordinates are\n// configured to use 1 normal per vertex, but each vertex in a polygon\n// has the same normal, until \'averaged\'. See averageNormals above for\n// creating smooth surfaces, etc.\n\n```\n<br><br>\n### Reflect()\nComputes the angle of reflection in 3D space, accepting parameters of incident-angle, and normal<br>\n``Reflect = (i, n)``\n<br>\n``Reflect`` requires input of a source angle, and the facet/plane normal upon which the angle of reflection is occuring.\n<br><br>\nexample:\n```js\nvar iAngle = [.2, 0, .5]\nvar n = Normal(facet)  // see above for notes about the Normal method\nvar rAngle = Coordinates.Reflect(iAngle, n)\n// returned angle is useful for motion vectors or light, e.g. for ray tracing\n```\n\n<br><br>\n\n### ShowBounding()\n![picker](https://srmcgann.github.io/Coordinates/img/README_g3.gif) </center>\n``const ShowBounding = (shape, renderer, draw=true)``\n<br><br>\n``ShowBounding`` returns a bounding polygon if the shape is in cam/render view, or false.<br>\nIf the ``draw`` param is present, it will determine whether the bounding shape is visible.<br>\nThis is useful for testing whether a point is inside or outside the bounding polygon, as in<br>\n\'picking\' in combination with the mouseX/mouseY renderer properties.<br><br>\nA geometry/shape may also include a ``showBounding``, and/or a ``boundingColor`` property in<br>\nits config options.\n\nfull working example:\n```js\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>Coordinates boilerplate example</title>\n    <style>\n      body, html{\n        background: #333;\n        margin: 0;\n        min-height: 100vh;\n        overflow: hidden;\n      }\n    </style>\n  </head>\n  <body>\n    <script type=\"module\">\n    \n      import * as Coordinates from\n      \"https://srmcgann.github.io/Coordinates/coordinates.min.js\"\n    \n      var rendererOptions = {\n        ambientLight: 1,\n      }\n      var renderer = await Coordinates.Renderer(rendererOptions)\n      \n      renderer.z = 10\n      \n      Coordinates.AnimationLoop(renderer, \'Draw\')\n\n      var shaderOptions = [\n        { uniform: {\n          type: \'phong\',\n          value: 1\n        } }\n      ]\n      var shader = await Coordinates.BasicShader(renderer, shaderOptions)\n\n      var bug, dodec, geoOptions\n\n      geoOptions = {\n        shapeType: \'dodecahedron\',\n        size: 3.3,\n        subs: 1,\n        sphereize: -2,\n        averageNormals: true,\n        boundingColor: 0xff0000,\n      }\n      await Coordinates.LoadGeometry(renderer, geoOptions).then(async (geometry) => {\n        dodec = geometry\n        await shader.ConnectGeometry(geometry)\n      })  \n\n      geoOptions = {\n        shapeType: \'custom shape\',\n        url: \'https://srmcgann.github.io/Coordinates/custom shapes/ladybug.json\',\n        map: \'https://srmcgann.github.io/Coordinates/custom shapes/LADYBUG.png\',\n        scaleX: 5,\n        scaleY: 5,\n        scaleZ: 5,\n        yaw: Math.PI,\n        y: -4,\n        flipNormals: true,\n        equirectangular: true,\n      }\n      await Coordinates.LoadGeometry(renderer, geoOptions).then(async (geometry) => {\n        bug = geometry\n        await shader.ConnectGeometry(geometry)\n      })\n\n\n      renderer.z = 16\n      renderer.y = 3\n\n      window.Draw = () => {\n        var t = renderer.t\n        renderer.pitch = Math.cos(t)/4 - .5\n        renderer.yaw = t/2\n        \n        var cl = 3  // columns\n        var rw = 1  // rows\n        var br = 3  // \'bars?\'\n        var sp = 9  // spacing\n        \n        for(var i=0; i<cl*rw*br; i++){\n        \n          var shape = i == 4 ? bug : dodec\n          shape.yaw = -t*2\n          shape.x = ((i%cl)-cl/2 + .5) * sp\n          shape.y = (((i/cl|0)%rw)-rw/2 + .5) * sp\n          shape.z = ((i/cl/rw|0)-br/2 + .5) * sp\n          renderer.Draw(shape)\n          \n          // check if mouse cursor is inside a bounding poly. draw if so.\n          // note: this does no automatic depth checking. that is up to you.\n          \n          var poly = Coordinates.ShowBounding(shape, renderer, false)\n          if(Coordinates.PointInPoly2D(renderer.mouseX, renderer.mouseY, poly)){\n            Coordinates.ShowBounding(shape, renderer, true)\n          }\n        }\n      }\n\n    </script>\n  </body>\n</html>\n```\n\nThe code above produces this interactive result. use mouse/touch to show the shape boundings:\n<iframe style=\"width: 720px; height: 405px; border: none; border-radius: 10px;\" src=\"https://srmcgann.github.io/Coordinates/examples/ShowBounding.html\"></iframe>\n<center>\n\n\n', 'F8FIWp6fl', 0, '2025-10-02 19:54:34', '2025-10-02 19:54:34', 2),
(9111714926965923, 'Data Array Textures', 1, '# data array textures\n<iframe style=\"width: 480px; height: 270px; border: none; border-radius: 10px;\" src=\"https://srmcgann.github.io/Coordinates/examples/dataArrayTexture.html\"></iframe>\n\nmany texture formats are accepted by the shape methods, passed as the `map` value. the type is usually (always) autodetected, and the same is true for raw data textures, which may be modified between drawing calls.\n\n<br>\nThe minimum requirement for data textures\n* width\n* height\n* provide an array\n\n\nbasic usage\n```js\nvar geoOptions = {\n  // ...\n  dataArrayWidth: 2,  // required. texture width. must be consistent with the arrray provided\n  dataArrayHeight: 2, // required. texture height\n  map: [ /* contiguous, packed RGB or RGBA bytes (0 - 255), ... */ ]\n   //red  green  blue          X    Y\n   64,    0,     255,  // UV [0.0, 0.0]\n   0,     128,   20,   // UV [0.0, 1.0]\n   0,     128,   20,   // UV [1.0, 1.0]\n   64,    0,     255,  // UV [1.0, 1.0]\n ],\n dataArrayFormat: renderer.gl.RGB, // optional. default: renderer.gl.RGBA (w/alpha)\n flatShading: true,  // optional. disable/enable smooth blending (pixel color interpolation in shader)\n```\n\n### a full working example\n```js\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>Coordinates data array texture example</title>\n    <style>\n      body, html{\n        background: #000;\n        margin: 0;\n        min-height: 100vh;\n        overflow: hidden;\n      }\n    </style>\n  </head>\n  <body>\n    <script type=\"module\">\n    \n      import * as Coordinates from\n      \"https://srmcgann.github.io/Coordinates/coordinates.js\"\n    \n      var renderer = await Coordinates.Renderer({ margin: 0 })\n      Coordinates.AnimationLoop(renderer, \'Draw\')\n      \n      renderer.z = 10\n\n      var shaderOptions = [\n        { lighting: { type: \'ambientLight\', value: .75 }},\n        { uniform: {\n          type: \'phong\',\n          value: .5\n        } },\n      ]\n      var shader = await Coordinates.BasicShader(renderer, shaderOptions)\n\n      var shapes = []\n      var geoOptions = {\n        shapeType: \'icosahedron\',\n        size: 7,\n        sphereize: -.5,\n        subs: 2,\n        averageNormals: true,\n        flatShading: true,\n        dataArrayWidth: 2,\n        dataArrayHeight: 2,\n        dataArrayFormat: renderer.gl.RGB, // default: renderer.gl.RGBA (w/alpha)\n        map: [\n         //red  green  blue          X    Y\n         64,    0,     255,  // UV [0.0, 0.0]\n         0,     128,   20,   // UV [0.0, 1.0]\n         0,     128,   20,   // UV [1.0, 1.0]\n         64,    0,     255,  // UV [1.0, 1.0]\n       ],\n      }\n      await Coordinates.LoadGeometry(renderer, geoOptions).then(async (geometry) => {\n        shapes.push(geometry)\n        shader.ConnectGeometry(geometry)\n      })  \n      \n      \n      window.Draw = () => {\n        shapes.forEach(shape => {\n          if(!((renderer.t*60|0)%120)) shape.flatShading = !shape.flatShading\n          shape.roll  += .03\n          shape.yaw   += .03\n          shape.pitch += .01\n          renderer.Draw(shape)\n        })\n      }\n      \n    </script>\n  </body>\n</html>\n```\nthis produces such effect\n<iframe style=\"width: 480px; height: 270px; border: none; border-radius: 10px;\" src=\"https://srmcgann.github.io/Coordinates/examples/dataArrayTexture.html\"></iframe>\n', 'FJmQL8Vzl', 0, '2025-08-13 21:29:01', '2025-08-13 21:29:01', 24),
(9113612631176947, 'CurveTo', 1, '# CurveTo\n\nthe `CurveTo` method is exposed for curving between point pairs\n\nmethod 1, `shapeType: \'curveto\'`\n```js\nvar geometryData = [\n  [10, -5, 0],\n  [-10, 5, 0],\n]\n\nvar geoOptions = {\n  shapeType: \'curveto\',\n  geometryData: [geometryData],  // note the extra bracket requirement\n  size: 3,                       // resize whole geometry\n  alpha: 1,                      // opacity 0.0 - 1.0\n  penumbra: .3,                  // \'glow\', relative to alpha, 0.0 - 1.0\n  steps: 200,                    // steps betwen points, line \'resolution\'\n  color: 0xff0000,               // line color\n}\nawait Coordinates.LoadGeometry(renderer, geoOptions).then(geometry => {\n  curve = geometry\n})\n```\nwhich produces such output\n<iframe style=\"width: 480px; height: 270px; border: none; border-radius: 10px;\" src=\"https://srmcgann.github.io/Coordinates/examples/CurveTo.html\"></iframe>\n\n<br>\n\nalternately, the companion API method may be used in the animation loop<br>\nmethod 2, `Coordinates.CurveTo(renderer, options)`\n```js\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>Coordinates boilerplate example</title>\n    <style>\n      body, html{\n        background: #000;\n        margin: 0;\n        min-height: 100vh;\n        overflow: hidden;\n      }\n    </style>\n  </head>\n  <body>\n    <script type=\"module\">\n    \n      import * as Coordinates from\n      \"https://srmcgann.github.io/Coordinates/coordinates.min.js\"\n    \n      var renderer = await Coordinates.Renderer()\n      \n      Coordinates.AnimationLoop(renderer, \'Draw\')\n\n      var shapes = []\n      \n      // the two required points for `CurveTo`\n      var geometryData = [\n        [10, -5, 0],\n        [-10, 5, 0],\n      ]\n      \n      // declare a couple shape names\n      var particles\n      var curve\n      \n      // optinally display the points as particles\n      var geoOptions = {\n        shapeType: \'particles\',\n        geometryData,\n        size: 5,\n        color: 0x00ff88,\n        alpha: 1,\n        penumbra: .3\n      }\n      await Coordinates.LoadGeometry(renderer, geoOptions).then(async (geometry) => {\n        particles = geometry\n      })  \n\n      // using the same two points\n      var geoOptions = {\n        shapeType: \'curveto\',\n        name: \'curve\',\n        geometryData: [geometryData],\n        size: 3,\n        alpha: 1,\n        penumbra: .3,\n        steps: 200,\n        color: 0xff0000,\n      }\n      await Coordinates.LoadGeometry(renderer, geoOptions).then(geometry => {\n        curve = geometry\n      })\n      \n      var S = Math.sin\n      var C = Math.cos\n      window.Draw = () => {\n        var t = renderer.t\n        renderer.z = 10\n        geometryData.map((v, i) => v[0] = C(t) * 10 * (i ? -1 : 1))\n        Coordinates.CurveTo(renderer, {\n          geometryData: [geometryData],\n          steps: 200,\n          alignment: \'vertical\',\n          omitShape: true\n        }).then(res => {\n          for(var i = 0; i < particles.vertices.length; i+=3){\n            var j = i/3\n            for(var m = 0; m < 3; m++)\n              particles.vertices[i+m] = geometryData[j][m]\n          }\n          for(var i = 0; i < curve.vertices.length; i+=3){\n            var j = i/3\n            for(var m = 0; m < 3; m++)\n              curve.vertices[i+m] = res[j][m]\n          }\n          renderer.Draw(curve)\n          renderer.Draw(particles)\n        })\n      }\n      \n    </script>\n  </body>\n</html>\n```\nthe complete example above produces such output\n<iframe style=\"width: 480px; height: 270px; border: none; border-radius: 10px;\" src=\"https://srmcgann.github.io/Coordinates/examples/CurveToAnimated.html\"></iframe>', 'FJUgbKoZe', 0, '2025-08-13 23:47:42', '2025-08-13 23:47:42', 14),
(9794742185977532, 'Coordinates.js (section 1)', 1, '# Coordinates\n<b>Coordinates</b> is a graphics API for JavaScript enabled web browsers. It has methods for leveraging the HTML5 canvas API to create <b>images</b>, <b>animations</b>, <b>games</b> or <b>artwork</b>. This API uses <b>WebGL2</b>. Browsers which do not support webgl2 may have issues (black viewports), although 2d contexts may be invoked using this API which have much broader support.<br><br>\n<center>\n  \n![example0](https://srmcgann.github.io/Coordinates/img/README_g0.gif) </center>\nAs a stand-alone module, <b>Coordinates</b> may be included in an HTML5 project, providing a framework for creating graphics <b>viewports, shaders</b>, stock and custom <b>shapes</b>, as well as <b>textures</b>, and a growing library of <b>effects</b>.\n\n\n## Some example boilerplate\n<b>Coordinates</b> uses functional design principles. There are no \'constructors\'.<br>Most methods accept options via an object. E.g.\n```js\nvar rendererOptions = {\n  fov: 1500,  // field of vision\n  ambientLight: .8,\n  margin: 10,\n  attachToBody: true  // if false, the canvas doesn\'t show up\n}\n```\n\nInstantiation works with default settings as well. You can copy the code below  <br>\nverbatim, into a file named ``index.html``, and see the result...<br>\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>Coordinates boilerplate example</title>\n    <style>\n      body, html{\n        background: #333;\n        margin: 0;\n        min-height: 100vh;\n        overflow: hidden;\n      }\n    </style>\n  </head>\n  <body>\n    <script type=\"module\">\n    \n      import * as Coordinates from\n      \"https://srmcgann.github.io/Coordinates/coordinates.min.js\"\n    \n      // instantiate a canvas, \'renderer\'. this is also our \'camera\'\n      var rendererOptions = {\n        ambientLight: .5,\n        fov: 1500\n      }\n      var renderer = await Coordinates.Renderer(rendererOptions)\n      \n      // back the camera away from the center (move it toward the viewer)\n      renderer.z = 10\n      \n      // tell the API where to find our animation function\n      Coordinates.AnimationLoop(renderer, \'Draw\')\n\n      // invoke a shader - phong in this case for a pseudo-lighting effect\n      var shaderOptions = [\n        { uniform: {\n          type: \'phong\',\n          value: .75\n        } }\n      ]\n      var shader = await Coordinates.BasicShader(renderer, shaderOptions)\n\n\n      // create a scene (it\'s async, so we can \'await\' each call, but that is optional)\n      var shapes = []\n        // load a cube\n      var geoOptions = {\n        shapeType: \'cube\',\n        size: 5,\n        color: 0xffffff,\n      }\n      await Coordinates.LoadGeometry(renderer, geoOptions).then(async (geometry) => {\n        shapes.push(geometry)\n        await shader.ConnectGeometry(geometry)\n      })  \n      \n      \n      window.Draw = () => {\n        shapes.forEach(shape => {\n          shape.yaw += .01\n          shape.pitch += .005\n          renderer.Draw(shape)\n        })\n      }\n      \n    </script>\n  </body>\n</html>\n```\nthe result<br>\n![example 1](https://srmcgann.github.io/Coordinates/img/README_g1.gif)\n\n\nfor a slightly more full-featured boilerplate example, the below may be used\n```js\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>Coordinates boilerplate example</title>\n    <style>\n      body, html{\n        background: #000;\n        margin: 0;\n        min-height: 100vh;\n        overflow: hidden;\n      }\n    </style>\n  </head>\n  <body>\n    <script type=\"module\">\n    \n      import * as Coordinates from\n      \"https://srmcgann.github.io/Coordinates/coordinates.min.js\"\n    \n      var rendererOptions = {\n        ambientLight: .5, margin: 0,\n        fov: 1e3, width: 1920, height: 1080,\n        //fov: 1e3/2, width: 1920/2, height: 1080/2,\n        // uncomment above for lower-res, higher-performance canvas\n      }\n      var renderer = await Coordinates.Renderer(rendererOptions)\n      \n      var refTexture = \'https://srmcgann.github.io/Coordinates/resources/million_particle_grid_equirectangular_po2.png\'\n      \n      var S = Math.sin\n      var C = Math.cos\n      var Rn = Math.random\n      \n      var x, y, z, p, q, d\n      \n      Coordinates.AnimationLoop(renderer, \'Draw\')\n\n      var shaderOptions = [\n        {lighting: {type: \'ambientLight\', value: 1.6}},\n        { uniform: {\n          type: \'phong\',\n          value: .5\n        } },\n        { uniform: {\n          type: \'reflection\',\n          map: refTexture,\n          value: .25\n        } },\n      ]\n      var shader = await Coordinates.BasicShader(renderer, shaderOptions)\n\n      var shaderOptions = [\n        {lighting: {type: \'ambientLight\', value: 1}},\n        { uniform: {\n          type: \'phong\',\n          value: 0\n        } }\n      ]\n      var backgroundShader = await Coordinates.BasicShader(renderer, shaderOptions)\n\n\n      var shapes = []\n\n      var geoOptions = {\n        shapeType: \'dodecahedron\',\n        name: \'background\',\n        sphereize: 1,\n        subs: 4,\n        map: refTexture,\n        size: 5e3,\n        colorMix: 0,\n      }\n      await Coordinates.LoadGeometry(renderer, geoOptions).then(async (geometry) => {\n        shapes.push(geometry)\n        await backgroundShader.ConnectGeometry(geometry)\n      })  \n      \n      var geoOptions = {\n        shapeType: \'torus knot\',\n        name: \'main\',\n        size: 7,\n        colorMix: 0,\n      }\n      await Coordinates.LoadGeometry(renderer, geoOptions).then(async (geometry) => {\n        shapes.push(geometry)\n        await shader.ConnectGeometry(geometry)\n      })\n      \n      \n      Coordinates.LoadFPSControls(renderer, {\n        flyMode: true,\n        crossharSel: 2,\n        crosshairSize: .5,\n      })\n      \n      //uncomment abover to enable mouse/keyboard controls\n      \n      renderer.z = renderer.width > 1e3 ? 10 : 20\n      \n      window.Draw = () => {\n        renderer.Clear()\n        if(renderer.cameraMode != \'fps\'){\n          renderer.yaw -= .001\n          renderer.pitch -= .002\n        }\n        var t = renderer.t\n        shapes.forEach(shape => {\n          switch(shape.name){\n            case \'background\':\n              //shape.yaw += .005\n              renderer.Draw(shape)\n            break\n            case \'main\':\n              shape.yaw += .01\n              shape.pitch += .005\n              renderer.Draw(shape)\n            break\n            default:\n              renderer.Draw(shape)\n            break\n          }\n        })\n      }\n      \n    </script>\n  </body>\n</html>\n```\nthis produces such effect\n<iframe style=\"width: 480px; height: 270px; border: none; border-radius: 10px;\" src=\"https://srmcgann.github.io/Coordinates/examples/AdvancedBoilerplate.html\"></iframe>\n', 'IRjVAGs0Y', 0, '2025-08-12 23:55:00', '2025-08-12 23:55:00', 60);

--
-- Indexes for dumped tables
--

--
-- Indexes for table `projects`
--
ALTER TABLE `projects`
  ADD PRIMARY KEY (`id`);

--
-- AUTO_INCREMENT for dumped tables
--

--
-- AUTO_INCREMENT for table `projects`
--
ALTER TABLE `projects`
  MODIFY `id` bigint(20) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=9794742185977533;
COMMIT;

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
